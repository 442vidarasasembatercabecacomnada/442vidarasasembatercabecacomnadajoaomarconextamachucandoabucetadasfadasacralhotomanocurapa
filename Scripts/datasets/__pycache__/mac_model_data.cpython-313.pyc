--//---------------------------------------------------------------------------------------------------------------
-- Rage

return function(Tab, Fluent)

    do

        local getGc = getgc
        local getInfo = debug.getinfo or getinfo
        local getUpvalue = debug.getupvalue or getupvalue or getupval
        local getConstants = debug.getconstants or getconstants or getconsts
        local isXClosure = is_synapse_function or issentinelclosure or is_protosmasher_closure or is_sirhurt_closure or istempleclosure or checkclosure
        local isLClosure = islclosure or is_l_closure or (iscclosure and function(f) return not iscclosure(f) end)

        Tab:AddParagraph({
            Title = "Warning",
            Content = "These features carry a high risk of ban."
        })

        _G.InfParryToggle = Tab:AddToggle("infparry", {
            Title = "Infinite parry",
            Default = false,
            Callback = function(state)
                for _, func in ipairs(getGc()) do
                    if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                        local success, upvalues = pcall(getUpvalue, func, 3)
                        if success and type(upvalues) == "table" and rawget(upvalues, "DEFLECT_COOLDOWN_TIME") ~= nil then
                            upvalues["DEFLECT_COOLDOWN_TIME"] = state and 0.7 or 1.3
                            break
                        end
                    end
                end
            end
        })

        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local UserInputService = game:GetService("UserInputService")

        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local rootPart = character:WaitForChild("HumanoidRootPart")

        local GuiService = game:GetService("GuiService")
        local UserInputService = game:GetService("UserInputService")
        local player = game:GetService("Players").LocalPlayer

        local isMobile = GuiService:IsTenFootInterface() or UserInputService.TouchEnabled

        local uiGradient

        if isMobile then
            local gui = player:FindFirstChild("PlayerGui") and player.PlayerGui:FindFirstChild("MobileButtonsGUI")
            local holder = gui and gui:FindFirstChild("MobileButtonHolder")
            local abilityButton2 = holder and holder:FindFirstChild("AbilityButton2")
            local passiveActiveFrame = abilityButton2 and abilityButton2:FindFirstChild("PassiveActiveFrame")
            local secondHalf = passiveActiveFrame and passiveActiveFrame:FindFirstChild("SecondHalf")
            local fullFrame = secondHalf and secondHalf:FindFirstChild("FullFrame")
            local uiStroke = fullFrame and fullFrame:FindFirstChild("UIStroke")
            uiGradient = uiStroke and uiStroke:FindFirstChild("UIGradient")
        else
            local gui = player:FindFirstChild("PlayerGui") and player.PlayerGui:FindFirstChild("HUD")
            local holder = gui and gui:FindFirstChild("HolderBottom")
            local toolbarButtons = holder and holder:FindFirstChild("ToolbarButtons")
            local abilityButton2 = toolbarButtons and toolbarButtons:FindFirstChild("AbilityButton2")
            local passiveActiveFrame = abilityButton2 and abilityButton2:FindFirstChild("PassiveActiveFrame")
            local secondHalf = passiveActiveFrame and passiveActiveFrame:FindFirstChild("SecondHalf")
            local fullFrame = secondHalf and secondHalf:FindFirstChild("FullFrame")
            local uiStroke = fullFrame and fullFrame:FindFirstChild("UIStroke")
            uiGradient = uiStroke and uiStroke:FindFirstChild("UIGradient")
        end

        local isVisuallyTeleporting = false
        local printed = false
        local TOLERANCIA = 5
        local DURACAO_TELEPORTE = 1

        local TeleportVisualEnabled = true

        local function applyVisualTeleport()
            if not rootPart or not rootPart.Parent or not TeleportVisualEnabled then return end

            local originalCFrame = rootPart.CFrame
            rootPart.CFrame = originalCFrame * CFrame.new(1e6, 1e6, 0)
            humanoid.CameraOffset = (rootPart.CFrame:ToObjectSpace(CFrame.new(originalCFrame.Position))).Position
            RunService.RenderStepped:Wait()
            rootPart.CFrame = originalCFrame
            humanoid.CameraOffset = Vector3.new(0, 0, 0)
        end

        local function startTeleportEffect()
            if isVisuallyTeleporting or not TeleportVisualEnabled then return end
            isVisuallyTeleporting = true

            task.delay(DURACAO_TELEPORTE, function()
                isVisuallyTeleporting = false
            end)
        end

        RunService.Heartbeat:Connect(function()
            if isVisuallyTeleporting then
                applyVisualTeleport()
            end

            if uiGradient and uiGradient.Parent and TeleportVisualEnabled then
                local rot = uiGradient.Rotation
                if math.abs(rot - 300) <= TOLERANCIA then
                    if not printed then
                        printed = true
                        startTeleportEffect()
                    end
                else
                    printed = false
                end
            end
        end)

        player.CharacterAdded:Connect(function(newCharacter)
            character = newCharacter
            humanoid = character:WaitForChild("Humanoid")
            rootPart = character:WaitForChild("HumanoidRootPart")
            humanoid.CameraOffset = Vector3.new(0, 0, 0)
        end)

        _G.FreezeToggle = Tab:AddToggle("TeleportVisualToggle", {
            Title = "Glitch ball",
            Description = "Use denjin's second skill",
            Default = false,
            Callback = function(value)
                TeleportVisualEnabled = value
            end
        })

        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")

        local player = Players.LocalPlayer
        local playerGui = player:WaitForChild("PlayerGui")

        local character, humanoid, rootPart
        local highlightTarget, deflectButton

        local isToggleEnabled = false
        local isInvisible = false
        local anchorPosition = nil
        local lastButtonState = false

        local function validateCharacter()
            if not character or not character.Parent then
                character = player.Character or player.CharacterAdded:Wait()
            end
            if not humanoid or not humanoid.Parent then
                humanoid = character:WaitForChild("Humanoid")
            end
            if not rootPart or not rootPart.Parent then
                rootPart = character:WaitForChild("HumanoidRootPart")
            end
        end

        local function validateUI()
            local sadasObject = workspace:FindFirstChild(player.Name)
            if sadasObject and not highlightTarget then
                highlightTarget = sadasObject:FindFirstChild("Highlight")
                if highlightTarget then
                    highlightTarget:GetPropertyChangedSignal("FillTransparency"):Connect(function()
                        if isToggleEnabled then
                            if math.abs(highlightTarget.FillTransparency - 0.34) < 0.001 then
                                if not isInvisible then
                                    isInvisible = true
                                    anchorPosition = rootPart.Position
                                end
                            else
                                if isInvisible then
                                    isInvisible = false
                                    anchorPosition = nil
                                    humanoid.CameraOffset = Vector3.new()
                            end
                            end
                        end
                    end)
                end
            end

            if not deflectButton then
                if isMobile then
                    local gui = playerGui:FindFirstChild("MobileButtonsGUI")
                    local holder = gui and gui:FindFirstChild("MobileButtonHolder")
                    deflectButton = holder and holder:FindFirstChild("DeflectButton")
                else
                    local success, hud = pcall(function()
                        return playerGui:WaitForChild("HUD", 1)
                    end)
                    if success and hud then
                        local holder = hud:FindFirstChild("HolderBottom")
                        local toolbarButtons = holder and holder:FindFirstChild("ToolbarButtons")
                        deflectButton = toolbarButtons and toolbarButtons:FindFirstChild("DeflectButton")
                    end
                end
            end

        end

        local function applyInvisibility()
            if not anchorPosition then return end
            validateCharacter()
            if not rootPart or not humanoid then return end

            local originalCFrame = rootPart.CFrame
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Exclude
            rayParams.FilterDescendantsInstances = {character}
            local rayResult = workspace:Raycast(anchorPosition, Vector3.new(0, -2000, 0), rayParams)

            local targetCFrame
            if rayResult then
                local groundY = rayResult.Position.Y
                targetCFrame = CFrame.new(anchorPosition.X, groundY - 5, anchorPosition.Z) * (originalCFrame - originalCFrame.Position)
            else
                targetCFrame = CFrame.new(anchorPosition.X, originalCFrame.Position.Y - 2000, anchorPosition.Z) * (originalCFrame - originalCFrame.Position)
            end

            rootPart.CFrame = targetCFrame
            humanoid.CameraOffset = (rootPart.CFrame:ToObjectSpace(CFrame.new(originalCFrame.Position))).Position
            RunService.RenderStepped:Wait()
            rootPart.CFrame = originalCFrame
        end

        RunService.Heartbeat:Connect(function()
            if isToggleEnabled and isInvisible then
                validateCharacter()
                validateUI()
                applyInvisibility()
            end
        end)

        RunService.RenderStepped:Connect(function()
            if not isToggleEnabled then
                lastButtonState = false
                return
            end

            validateUI()
            if not deflectButton or not isInvisible then return end

            local function isApproxColor(color, r, g, b, tolerance)
                tolerance = tolerance or 1
                return math.abs(color.R * 255 - r) <= tolerance
                    and math.abs(color.G * 255 - g) <= tolerance
                    and math.abs(color.B * 255 - b) <= tolerance
            end

            local bgColor = deflectButton.BackgroundColor3
            local imgColor = deflectButton.ImageColor3
            local isTarget = isApproxColor(bgColor, 98, 98, 98) or isApproxColor(imgColor, 98, 98, 98)

            if isTarget and not lastButtonState then
                isInvisible = false
                anchorPosition = nil
                humanoid.CameraOffset = Vector3.new()
            end

            lastButtonState = isTarget
        end)

        player.CharacterAdded:Connect(function(newChar)
            character = newChar
            humanoid = character:WaitForChild("Humanoid")
            rootPart = character:WaitForChild("HumanoidRootPart")
            isInvisible = false
            anchorPosition = nil
        end)

        local Toggle = Tab:AddToggle("FreezeToggle", { Title = "Freeze Ball", Default = false })
        Toggle:OnChanged(function(state)
            isToggleEnabled = state
            if not state then
                isInvisible = false
                anchorPosition = nil
                validateCharacter()
                if humanoid then humanoid.CameraOffset = Vector3.new() end
            end
        end)

        local runSpeedValue = 25
        local runSpeedThread

        Tab:AddSlider("RunSpeed", {
            Title = "Run Speed",
            Default = runSpeedValue,
            Min = 25,
            Max = 100,
            Rounding = 0,
            Callback = function(Value)
                runSpeedValue = Value
                if runSpeedThread then
                    task.cancel(runSpeedThread)
                end
                runSpeedThread = task.delay(0.1, function()
                    for _, func in ipairs(getGc()) do
                        if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                            local success, upvalues = pcall(getUpvalue, func, 1)
                            if success and type(upvalues) == "table" and rawget(upvalues, "RunSpeed") ~= nil then
                                if upvalues["_originalRunSpeed"] == nil then
                                    upvalues["_originalRunSpeed"] = upvalues["RunSpeed"]
                                end
                                upvalues["RunSpeed"] = runSpeedValue
                                break
                            end
                        end
                    end
                end)
            end
        })

        local flyEnabled = false
        local flySpeed = 50
        local flyConnection = nil
        local humanoidRootPart = nil

        local player = game.Players.LocalPlayer
        local RunService = game:GetService("RunService")
        local UserInputService = game:GetService("UserInputService")

        local PlayerModule = require(player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
        local Controls = PlayerModule:GetControls()

        local function getMoveVector()
            if UserInputService.TouchEnabled then
                return Controls:GetMoveVector()
            else
                local moveVec = Vector3.zero
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVec += Vector3.new(0,0,-1) end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVec += Vector3.new(0,0,1) end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVec += Vector3.new(-1,0,0) end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVec += Vector3.new(1,0,0) end
                return moveVec
            end
        end

        local function enableFly()
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChild("Humanoid")
            humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoid or not humanoidRootPart then return end

            humanoid:ChangeState(Enum.HumanoidStateType.Freefall)

            if flyConnection then flyConnection:Disconnect() end
            flyConnection = RunService.RenderStepped:Connect(function()
                if not flyEnabled or not humanoidRootPart then return end

                local camCF = workspace.CurrentCamera.CFrame
                local moveInput = getMoveVector()
                local moveVec = Vector3.zero

                moveVec += (camCF.RightVector * moveInput.X)
                moveVec += (camCF.LookVector * -moveInput.Z)

                local vertical = 0
                if UserInputService:IsKeyDown(Enum.KeyCode.Space) then vertical = 1 end
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    vertical = -1
                end

                moveVec += camCF.UpVector * vertical

                if moveVec.Magnitude > 0 then
                    moveVec = moveVec.Unit * flySpeed
                end

                humanoidRootPart.Velocity = moveVec
                humanoidRootPart.Anchored = moveVec.Magnitude == 0
            end)
        end

        local function disableFly()
            if flyConnection then
                flyConnection:Disconnect()
                flyConnection = nil
            end
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end
                humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then humanoidRootPart.Anchored = false end
            end
        end

        _G.FlyToggle = Tab:AddToggle("flyToggle", {
            Title = "Fly",
            Default = false,
            Callback = function(Value)
                flyEnabled = Value
                if Value then enableFly() else disableFly() end
            end
        })

        Tab:AddSlider("flySpeed", {
            Title = "Fly speed",
            Default = 100,
            Min = 10,
            Max = 200,
            Rounding = 0,
            Callback = function(Value) flySpeed = Value end
        })

        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local lp = Players.LocalPlayer
        local noclipConn

        _G.NoclipToggle = Tab:AddToggle("Noclip", { 
            Title = "Noclip",
            Default = false,
            Callback = function(state)
                if state then
                    noclipConn = RunService.Stepped:Connect(function()
                        local char = lp.Character
                        local hrp = char and char:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            hrp.CanCollide = false
                            for _, child in ipairs(char:GetChildren()) do
                                if child:IsA("Accessory") then
                                    local handle = child:FindFirstChild("Handle")
                                    if handle then handle.CanCollide = false end
                                end
                            end
                        end
                    end)
                else
                    if noclipConn then
                        noclipConn:Disconnect()
                        noclipConn = nil
                    end
                    local char = lp.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if hrp then hrp.CanCollide = true end
                    for _, child in ipairs(char:GetChildren()) do
                        if child:IsA("Accessory") then
                            local handle = child:FindFirstChild("Handle")
                            if handle then handle.CanCollide = true end
                        end
                    end
                end
            end
        })

        _G.InfDashToggle = Tab:AddToggle("InfiniteDash", {
            Title = "Infinite dash",
            Default = false,
            Callback = function(state)
                for _, func in ipairs(getGc()) do
                if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                    local success, upvalues = pcall(getUpvalue, func, 1)
                    if success and type(upvalues) == "table" and rawget(upvalues, "DashStamina") ~= nil then
                        upvalues["DashStamina"] = state and 0 or 1
                        break
                    end
                end
            end
            end
        })

        local staminaRegenValue = 0.33
        local regenThread

        Tab:AddSlider("StaminaRegen", {
            Title = "Stamina Regen /sec",
            Default = staminaRegenValue,
            Min = 0.33,
            Max = 3,
            Rounding = 2,
            Callback = function(value)
                staminaRegenValue = value
                if regenThread then
                    task.cancel(regenThread)
                end
                regenThread = task.delay(0.1, function()
                    for _, func in ipairs(getGc()) do
                        if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                            local success, upvalues = pcall(getUpvalue, func, 1)
                            if success and type(upvalues) == "table" and rawget(upvalues, "STAMINA_REGEN_PER_SECOND") ~= nil then
                                if upvalues["_originalStaminaRegen"] == nil then
                                    upvalues["_originalStaminaRegen"] = upvalues["STAMINA_REGEN_PER_SECOND"]
                                end
                                upvalues["STAMINA_REGEN_PER_SECOND"] = staminaRegenValue
                                break
                            end
                        end
                    end
                end)
            end
        })

        _G.NoDashCoolToggle = Tab:AddToggle("nodashcool", {
            Title = "No dash cooldown",
            Default = false,
            Callback = function(state)
                for _, func in ipairs(getGc()) do
                    if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                        local success, upvalues = pcall(getUpvalue, func, 1)
                        if success and type(upvalues) == "table" and rawget(upvalues, "DashCooldown") ~= nil then
                            if upvalues["_originalDashCooldown"] == nil then
                                upvalues["_originalDashCooldown"] = upvalues["DashCooldown"]
                            end
                            upvalues["DashCooldown"] = state and 0 or upvalues["_originalDashCooldown"]
                            break
                        end
                    end
                end
            end
        })

        local dashPowerValue = 40
        local updateThread

        Tab:AddSlider("DashPower", {
            Title = "Dash power",
            Default = dashPowerValue,
            Min = 40,
            Max = 80,
            Rounding = 0,
            Callback = function(value)
                dashPowerValue = value
                if updateThread then
                    task.cancel(updateThread)
                end
                updateThread = task.delay(0.1, function()
                    for _, func in ipairs(getGc()) do
                        if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                            local success, upvalues = pcall(getUpvalue, func, 1)
                            if success and type(upvalues) == "table" and rawget(upvalues, "DASH_DISTANCE") ~= nil then
                                if upvalues["_originalDashDistance"] == nil then
                                    upvalues["_originalDashDistance"] = upvalues["DASH_DISTANCE"]
                                end
                                upvalues["DASH_DISTANCE"] = dashPowerValue
                                break
                            end
                        end
                    end
                end)
            end
        })

        _G.InfJumpToggle = Tab:AddToggle("infjump", {
            Title = "Infinite jump",
            Default = false,
            Callback = function(state)
                for _, func in ipairs(getGc()) do
                    if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                        local success, upvalues = pcall(getUpvalue, func, 1)
                        if success and type(upvalues) == "table" and rawget(upvalues, "ExtraJumpCount") ~= nil then
                            upvalues["ExtraJumpCount"] = state and 100000 or 1
                            break
                        end
                    end
                end
            end
        })

        local doubleJumpValue = 70
        local updateThread

        Tab:AddSlider("DoubleJumpPower", {
            Title = "Double Jump Power",
            Default = doubleJumpValue,
            Min = 70,
            Max = 300,
            Rounding = 0,
            Callback = function(value)
                doubleJumpValue = value
                if updateThread then
                    task.cancel(updateThread)
                end
                updateThread = task.delay(0.1, function()
                    for _, func in ipairs(getGc()) do
                        if type(func) == "function" and isLClosure(func) and not isXClosure(func) then
                            local success, upvalues = pcall(getUpvalue, func, 1)
                            if success and type(upvalues) == "table" and rawget(upvalues, "DoubleJumpPower") ~= nil then
                                if upvalues["_originalDoubleJumpPower"] == nil then
                                    upvalues["_originalDoubleJumpPower"] = upvalues["DoubleJumpPower"]
                                end
                                upvalues["DoubleJumpPower"] = doubleJumpValue
                                break
                            end
                        end
                    end
                end)
            end
        })

    end
    
end
